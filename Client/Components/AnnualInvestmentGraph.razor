<h3>Annual Returns</h3>

@using BlazorBootstrap
@using Color = System.Drawing.Color
@using System.ComponentModel.DataAnnotations
@using System.Net.Http.Json
@using Newtonsoft.Json

@inject HttpClient httpClient

<div class="container">
    <div class="row">
        <div class="col-md-6">
            <input type="number" @bind="initialInvestment" />
            <button class="btn btn-primary" @onclick="UpdateGraph">Update</button>
        </div>
        <div class="col-md-6">
            <input type="text" @bind="stockTicker" />
            <button class="btn btn-primary" @onclick="AddStockLine">Add Stock Line</button>
        </div>
    </div>
    <div class="row">
        <div style="width: 90%; margin: auto;">
            <LineChart @ref="lineChart" ChartData="chartData" Options="lineChartOptions" Class="mb-4 unique-line-chart-width" />
        </div>
    </div>
</div>


@code {
    private LineChart lineChart = default!;
    private LineChartOptions lineChartOptions = default!;
    private ChartData chartData = default!;
    private int labelsCount;
    private double initialInvestment;
    private string stockTicker = "";
    private string apiBaseUrl = "https://localhost:7283";
    private HashSet<int> allYears = new HashSet<int>();
    private List<string> labels;
    private List<LineChartDataset> datasets = new List<LineChartDataset>();

    private Dictionary<string, Dictionary<int, double>> investments = new();

    public class StockAnnualReturnsResponse
    {
        public string? Symbol { get; set; }
        public Dictionary<int, double>? AnnualReturns { get; set; }
    }

    // Initialization before user chooses a graph
    protected override void OnInitialized()
    {
        var colors = ColorBuilder.CategoricalTwelveColors;
        const double interestRate = 2.0; // 2% annual interest rate

        var labels = Enumerable.Range(2005, 20).Select(year => year.ToString()).ToList(); // Years from now to 20 years later

        double cumulativeAmount = initialInvestment;
        var dataValues = new List<double>();

        // Simulate each year's growth at a fixed interest rate
        for (int i = 0; i < 20; i++)
        {
            cumulativeAmount *= (1 + interestRate / 100);
            dataValues.Add(cumulativeAmount);
        }

        var dataset = new LineChartDataset()
            {
                Label = "Savings Account Growth",
                Data = dataValues,
                BackgroundColor = new List<string> { colors[0] },
                BorderColor = new List<string> { colors[0] },
                BorderWidth = new List<double> { 2 },
                HoverBorderWidth = new List<double> { 4 },
                PointBackgroundColor = new List<string> { colors[0] },
                PointRadius = new List<int> { 0 },
                PointHoverRadius = new List<int> { 4 },
                
            };

        chartData = new ChartData
            {
                Labels = labels,
                Datasets = new List<IChartDataset> { dataset }
            };

        lineChartOptions = new LineChartOptions();
        {
            lineChartOptions.Responsive = true;
            lineChartOptions.Interaction = new Interaction { Mode = InteractionMode.Index };

            lineChartOptions.Scales.X!.Title!.Text = "Year";
            lineChartOptions.Scales.X!.Title!.Display = true;

            lineChartOptions.Scales.Y!.Title!.Text = "Cumulative Amount ($)";
            lineChartOptions.Scales.Y!.Title!.Display = true;

            lineChartOptions.Plugins.Title!.Text = "Savings Account Growth Over 20 Years at 2% Interest";
            lineChartOptions.Plugins.Title.Display = true;

        };
    }

    private async Task FetchAnnualReturns(string symbol)
    {
        var url = $"{apiBaseUrl}/GetAnnualReturns?symbol={symbol}";
        try
        {
            var response = await httpClient.GetAsync(url);
            if (response.IsSuccessStatusCode)
            {
                var stockAnnualReturnsResponse = await response.Content.ReadFromJsonAsync<StockAnnualReturnsResponse>();
                if (stockAnnualReturnsResponse != null && stockAnnualReturnsResponse.AnnualReturns != null)
                {
                    // Add the fetched annual returns to the investments dictionary
                    investments[symbol] = stockAnnualReturnsResponse.AnnualReturns;

                    // Now update the chart with all current investments
                    await UpdateGraph();
                }
            }
            else
            {
                Console.WriteLine("Error fetching data: " + response.StatusCode);
            }
        }
        catch (HttpRequestException e)
        {
            Console.WriteLine("Exception caught: " + e.Message);
        }
    }

    private async Task UpdateGraph()
    {
        // Calculate labels count based on the range of years present in investments
        labelsCount = allYears.Count();
        var datasets = new List<IChartDataset>();
        var colors = ColorBuilder.CategoricalTwelveColors;
        int colorIndex = 0;

        // Update allYears to include any new years from the investments
        allYears.Clear();
        allYears.UnionWith(investments.SelectMany(i => i.Value.Keys));

        // Calculate savings data
        var savingsData = CalculateSavingsData(initialInvestment);
        var savingsDataset = new LineChartDataset
            {
                Label = "Savings",
                Data = savingsData,
                BackgroundColor = new List<string> { colors[colorIndex % colors.Count()] },
                BorderColor = new List<string> { colors[colorIndex % colors.Count()] },
                BorderWidth = new List<double> { 2 },
                HoverBorderWidth = new List<double> { 4 },
                PointBackgroundColor = new List<string> { colors[colorIndex % colors.Count()] },
                PointRadius = new List<int> { 1 },
                PointHoverRadius = new List<int> { 4 },
                Fill = false // Do not fill under the line
            };

        datasets.Add(savingsDataset);
        colorIndex++;

        // Add other investment datasets
        foreach (var investment in investments)
        {
            var dataValues = new List<double>(); // List to hold the yearly cumulative values

            foreach (var year in allYears.OrderBy(y => y))
            {
                // Initialize cumulativeAmount with the current initial investment for each year
                double cumulativeAmount = initialInvestment;

                // Only calculate the cumulative amount if there's a return value for that year
                if (investment.Value.TryGetValue(year, out double returnPercent))
                {
                    cumulativeAmount *= 1 + (returnPercent / 100);
                }
                else if (dataValues.Count > 0) // If there's no return for the year, use the last known cumulativeAmount
                {
                    cumulativeAmount = dataValues.Last();
                }

                dataValues.Add(cumulativeAmount); // Add the calculated cumulative amount to the list
            }

            var dataset = new LineChartDataset()
                {
                    Label = investment.Key + " Annual Returns",
                    Data = dataValues,
                    BackgroundColor = new List<string> { colors[colorIndex % colors.Count()] },
                    BorderColor = new List<string> { colors[colorIndex % colors.Count()] },
                    BorderWidth = new List<double> { 2 },
                    HoverBorderWidth = new List<double> { 4 },
                    PointBackgroundColor = new List<string> { colors[colorIndex % colors.Count()] },
                    PointRadius = new List<int> { 1 },
                    PointHoverRadius = new List<int> { 4 },
                    Fill = false // Do not fill under the line
                };

            datasets.Add(dataset);
            colorIndex++;
        }

        // Update the chartData with the new datasets and labels
        chartData.Datasets = datasets;
        chartData.Labels = allYears.OrderBy(y => y).Select(y => y.ToString()).ToList();

        // If the lineChart has been initialized, update it with the new data
        if (lineChart != null)
        {
            // This may be an asynchronous call depending on your charting library, ensure it is awaited if necessary
            await lineChart.UpdateAsync(chartData, lineChartOptions);
        }
    }

    private List<double> CalculateSavingsData(double initialInvestment)
    {
        const double interestRate = 2.0; // 2% annual interest rate
        double cumulativeAmount = initialInvestment;
        var dataValues = new List<double>();

        // Simulate each year's growth at a fixed interest rate
        for (int i = 0; i < labelsCount; i++)
        {
            cumulativeAmount *= (1 + interestRate / 100);
            dataValues.Add(cumulativeAmount);
        }

        return dataValues;
    }

    private async Task AddStockLine()
    {
        await FetchAnnualReturns(stockTicker);
    }

    private List<double> CalculateInvestmentData(Dictionary<int, double> annualReturns)
    {
        // Calculate investment data based on annual returns
        // and number of years
        // Example logic:
        var investmentData = new List<double>();
        foreach (var year in annualReturns.Keys.OrderBy(y => y))
        {
            investmentData.Add(annualReturns[year]);
        }
        return investmentData;
    }

    private async Task RemoveInvestmentLine(string symbol)
    {
        if (investments.ContainsKey(symbol))
        {
            investments.Remove(symbol);
            await UpdateGraph();
        }
    }

    private async Task OnRemoveInvestmentLineClicked(string symbol)
    {
        await RemoveInvestmentLine(symbol);
    }

    private List<string> GetDefaultDataLabels(int numberOfLabels)
    {
        var labels = new List<string>();
        for (var index = 0; index < numberOfLabels; index++)
        {
            labels.Add((index + 1).ToString()); // Assuming labels are numeric (years)
        }

        return labels;
    }
}